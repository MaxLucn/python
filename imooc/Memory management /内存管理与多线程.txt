赋值语句内存分析：
    使用 id() 方法访问内存地址
    使用 is 比较内存引用地址是否相等
垃圾回收机制:
    以引用计数为主，分带收集为辅
    引用计数： 每个对象都有存有指向该对象的引用总数
            查看某个对象的引用计数  sys.getrefcount()
            可以使用 del 关键字删除某个引用
    如果一个对象的引用数为0， python 虚拟机就会回收这个对象的内存
    引用计数的缺陷是循环引用的问题
内存管理机制: Pymalloc
    内存池机制：针对小对象（<=512bytes），pymalloc会在内存池中申请内存空间
id() \ is 的使用　



进程、线程、协程
        1、线程使用场景：爬虫、多用户同时访问 web 访问、秒杀活动、物联网传感器监控服务器
        2、进程：是一个执行中的程序
             1、 每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据
             2、操作系统管理其上所有进程的执行，并为这些进程合理的分配时间
             3、进程可以通过派生（fork 或 spawn）新的进程来执行其他任务
        3、线程：在同一个进程下执行，并共享相同的上下文
            1、一个进程中的各个线程与主线程共享同一片数据空间
            2、线程包括开始、执行顺序和结束三部分
            3、它可以被抢占（中断）和临时挂起（睡眠）
            4、一般是以并发方式执行
                并发：是一种属性、如果两个事件互不影响，则两个事件是并发的
        4、协程：协程就是协同多任务
             1、协程在一个进程或者是一个线程中执行
             2、不需要锁机制
             3、对多核 CPU 的利用——————多进程 + 协程
             4、async 关键字
                    1、定义特殊函数： async def  async_f()
                                        pass
                    2、当被调用时，不执行里面的代码，而是返回一个协程对象
                    3、在事件循环中调度其执行前，协程对象不执行任何操作
             5、await 关键字
                    1、等待协程执行完成
                    2、当遇到阻塞调用的函数的时候，使用 await 方法将协程的控制权让出，以便 loop 调用其他的协程
             6、asyncio 模块
                    get_event_loop()获得事件循环队列
                    run_until_complete() 注册任务到队列
                    在事件循环中调度其执行前，协程对象不执行任何操作
                    asyncio 模块用于事件循环
进程、线程与并发
对多核的利用
    1、单核 CPU 系统中， 不存在真正的并发
    2、GIL---全局解释器锁，强制在任何时候只有一个线程可以执行 python 代码
        GIL 执行顺序：
            1、设置 GIL
            2、切换进一个线程去运行
            3、执行下面操作之一：
                指定数量的字节码指令
                线程主动让出控制权（可以调用 times.sleep(0)来完成
            4、把线程设置回睡眠状态（切换线程）
            5、解锁 GIL
            6、重复上述步骤
    3、I/O 密集型应用与 CPU 密集型应用
实现多个线程：threading
线程之间的通信
线程的调度和优化:线程池

